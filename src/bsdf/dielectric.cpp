#include <nori/bsdf.h>
#include <nori/frame.h>

NORI_NAMESPACE_BEGIN

/// Ideal dielectric BSDF
class Dielectric : public BSDF {
public:
    Dielectric(const PropertyList &propList) {
        m_type = BSDFType::BSDF_DIELECTRIC;
        /* Interior IOR (default: BK7 borosilicate optical glass) */
        m_intIOR = propList.getFloat("intIOR", 1.5046f);

        /* Exterior IOR (default: air) */
        m_extIOR = propList.getFloat("extIOR", 1.000277f);

        // m_tex_filename = propList.getString("filename", "none");
		// if (m_tex_filename != "none")
		// {
		// 	m_hasTexture = true;
		// 	m_texture = Texture(m_tex_filename);
		// }
    }
/*---------------------------------------------------------------------------------------------------------------------------------------------*/
    Color3f eval(const BSDFQueryRecord &) const {
        /* Discrete BRDFs always evaluate to zero in Nori */
        return BLACK;
    }
/*---------------------------------------------------------------------------------------------------------------------------------------------*/
    float pdf(const BSDFQueryRecord &) const {
        /* Discrete BRDFs always evaluate to zero in Nori */
        return 0.0f;
    }
/*---------------------------------------------------------------------------------------------------------------------------------------------*/
    Color3f sample(BSDFQueryRecord &bRec, const Point2f &sample) const
    {
        float cosThetaI = bRec.wi.z();
        // refract
        float reflectivity = fresnel(cosThetaI, m_extIOR, m_intIOR, bRec.wi, bRec.wo);
        // reflect
        if (sample.x() < reflectivity)
        {
            bRec.wo = Vector3f(-bRec.wi.x(), -bRec.wi.y(), bRec.wi.z());
        }
        bRec.measure = EDiscrete;
        // The light is projected directly, and the cos item is generated by the projection solid angle, so there is no need to add an additional cos item
        return Color3f(1.f);
    }
    Color3f sample(BSDFQueryRecord &bRec, Sampler* sampler) const
    {
        return sample(bRec, sampler->next2D());
    }
/*---------------------------------------------------------------------------------------------------------------------------------------------*/
    std::string toString() const {
        return tfm::format(
            "Dielectric[\n"
            "  intIOR = %f,\n"
            "  extIOR = %f\n"
            "]",
            m_intIOR, m_extIOR);
    }
private:
    float m_intIOR, m_extIOR;
};

NORI_REGISTER_CLASS(Dielectric, "dielectric");
NORI_NAMESPACE_END
